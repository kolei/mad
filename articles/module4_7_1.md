# Проект "Каршеринг" (часть I)

## Техническое задание

**Модуль 1** 

Разработка мобильного приложения для бронирования автомобилей (каршеринг)

Необходимо разработать мобильное приложение для смартфона, удовлетворяющее следующим требованиям:

Приложение должно поддерживать следующие версии ОС:

* Android 9.0 и новее
* iOS 13.0 и новее

В работе необходимо использовать систему контроля версий **Git**.

Необходимо загрузить результаты выполнения модуля в отдельную ветку с именем `Module_X`, где `Х` – это номер модуля. Каждый модуль должен быть в отдельном репозитории.

Необходимо корректно обрабатывать запросы к серверу. В случае получения ошибки от сервера или отсутствия соединения с сетью Интернет необходимо отобразить соответствующий текст ошибки с помощью диалогового окна.

Необходимо строго следовать предложенному дизайну. Макеты приложения доступны по ссылке:
TODO добавить ссылку на фигму

Описание протокола API доступно по ссылке:
http://swagger.kolei.ru/?url=http://carsharing.kolei.ru/swagger/api.yml

Проект приложения должен быть структурирован по экранам, то есть исходные файлы конкретного экрана должны быть в соответствующей папке. Общие для нескольких экранов классы необходимо поместить в папку `common`.

Необходимо реализовать следующий функционал:

1. Создайте проект. Настройте иконку приложения согласно макету. Следует учесть разницу в отображении иконок на различных версиях операционной системы.

2. Реализуйте экран *Launch Screen* согласно макету. Текст должен быть отдельным элементом. Логотип приложения должен быть расположен по центру экрана. При первом запуске приложения после `Launch Screen` должен отображаться `SignUp Screen`. При последующих - `SignIn Screen`.

3. Реализуйте экран `SignUp Screen` согласно макету:
    * При нажатии на кнопку "Зарегистрироваться" необходимо проверять поля для ввода на пустоту, а также телефон на корректность (требования к телефону описаны в документации к API). При некорректном заполнении необходимо отобразить ошибку с помощью диалогового окна. Так же необходимо проверять равенство пароля и его повтора.
    * При корректном заполнении формы необходимо отправлять запрос регистрации на сервер. При получении ошибки от сервера ее необходимо отобразить с помощью диалогового окна. При успешной регистрации нужно автоматически осуществить авторизацию и перейти на `Main Screen`.
    * При нажатии на кнопку "У меня уже есть аккаунт" необходимо осуществлять переход на `SignIn Screen`.
    * при нажатии на ссылку "Оферта" необходимо открыть web-страничку с текстом оферты

4. Реализуйте экран `SignIn Screen` согласно макету:
    * При нажатии на кнопку "Войти" необходимо проверять поля для ввода на пустоту, а также телефон на корректность (требования к телефону описаны в документации к API). При некорректном заполнении необходимо отобразить ошибку с помощью диалогового окна. При корректном заполнении формы необходимо отправить на сервер соответствующий запрос.
    * При нажатии на кнопку "Регистрация" необходимо осуществлять переход на `SignUp Screen`.
    * При успешной авторизации необходимо осуществлять переход на экран `Main Screen` или `Profile Screen`, в зависимости от состояния пользователя (см. п.6 технического задания). При получении ошибки от сервера необходимо отобразить её с помощью диалогового окна.

5. Реализуйте экран `Profile Screen` согласно макету:
    * На экране необходимо отобразить аватарку пользователя. Рамка вокруг аватарки должна быть разного цвета в зависимости от состояния профиля:
        - *желтый*: не загружены фотографии водительских прав или паспорта
        - *красный*: есть штрафы от ГИБДД или претензии от владельца каршеринга
        - *зелёный*: всё OK (активный профиль)
    * При нажатии на аватарку открыть приложение "Камера" и полученную миниатюру отправить на сервер и заменить ею существующую аватрку.
    * При нажатии на кнопки "Загрузить фото водительских прав" или "Загрузить файл паспорта" открыть приложение "Галерея" и выбранный файл отправить на сервер.

6. Реализуйте экран `Main Screen` согласно макету:
    * На экране необходимо отобразить google-карту с текущей позицией и маркерами автомобилей (список доступных автомобилей получить с сервера).
    * при клике на маркер автомобиля показывать краткую информацию об автомобиле (popup): марка автомобиля, фото, кнопки "забронировать" и "маршрут". Кнопка "забронировать" должна быть только у активного пользователя
    * при клике на кнопку "Забронировать" открыть окно `Booking Screen`
    * При клике на кнопку "маршрут" закрыть popup и проложить маршрут от текущей позиции пользователя до выбранного автомобиля
    * При нажатии на иконку профиля необходимо переходить на `Profile Screen`.

7. Реализуйте экран `Booking Screen` согласно макету:

## Формирование данных в JSON формате (регистрация и авторизация). Получение, хранение и применение токена авторизации (способы авторизации). LiveData, глобальные свойства в классе приложения.

Создание приложения с иконкой, репозитория и ветки для модуля 1 я расписывать не буду, с этим вы уже знакомы. 

### Хранение данных в памяти устройства

Разберёмся как узнать: в первый раз мы запустили приложение или нет.

Подробно [тут](https://startandroid.ru/ru/uroki/vse-uroki-spiskom/73-urok-33-hranenie-dannyh-preferences.html)

Мы в качестве внешнего хранилища будем использовать **Preferences**. Это знакомый уже нам способ хранения данных в виде пары: **имя**, **значение**. Данные записываются в память телефона и доступны нам после перезапуска приложения.

Для получения экземпляра хранилища мы должны вызвать метод *getSharedPreferences*:

```kt
val myPreferences = getSharedPreferences(
    "settings", 
    MODE_PRIVATE)
```

где:
* "settings" - произвольное название вашего хранилища (их у вас может быть несколько)
* Константа MODE_PRIVATE используется для настройки доступа и означает, что после сохранения, данные будут видны только этому приложению

После получения экземпляра хранилища мы можем читать и писать в него значения.

Чтение простое:

```kt
val isFirstEnter = myPreferences
    .getBoolean(
        "isFirstEnter", 
        true)
```

Используя get-методы (*getString*, *getBoolean* и т.д.) мы можем получить сохранённые данные или значения по-умолчанию, если такого параметра нет в хранилище

Таким образом при первом входе в приложение мы получим `isFirstEnter = true`. 

Теперь нам необходимо записать в этот параметр значение `false`, чтобы при следующем входе знать, что это уже не первый вход в приложение.

Процесс записи несколько сложнее:

```kt
val editor = myPreferences.edit()
try {
    editor.putBoolean(
        "isFirstEnter", 
        false )
} finally {
    editor.commit()
}
```

Мы должны получить объект **Editor**, в котором реализованы методы сохранения данных (*putString*, *putBoolean* ...), вызвать нужный метод и после записи данных вызвать подтверждение записи в хранилище (метод *commit*)

### Регистрация и авторизация. Swagger.

Сначала об автоматическом переходе по ссылке на веб-сайт из текстового поля (да, можно по клику запускать интент и система откроет браузер, но можно и проще):

```xml
<TextView
    android:autoLink="web"
    android:linksClickable="true"
    android:text="Оферта: carsharing.kolei.ru/public/oferta.html"
/>
```

Элемент **TextView** поддерживает автоматический переход по ссылкам, достаточно указать какие типы ссылок искать в тексте (у нас указано искать веб-адреса `android:autoLink="web"`, но можно в этот атрибут добавить ключевое слово `phone` и можно будет позвонить).

**Swagger** - это фреймворк для спецификации *RESTful API*. Его прелесть заключается в том, что он дает возможность не только интерактивно просматривать спецификацию, но и отправлять запросы.

Открываем [ссылку](http://swagger.kolei.ru?url=http://carsharing.kolei.ru/swagger/api.yml) на описание АПИ и смотрим что там есть:

![](../img/mad_03.png)

В начале идёт общая информация. Нам тут пока интереснен только так называемый базовый URL. Здесь он находится в блоке **Servers** (`http://carsharing.kolei.ru`), но может быть написан и просто текстом (как базовый урл для картинок).

Дальше идут описания методов АПИ. Рассмотрим подробно метод "Регистрация":

![](../img/mad_04.png)

1. В заголовке указано какой метод и "путь" используются для запроса. К пути надо добавить "базовый урл" и получим полный адрес запроса: `http://carsharing.kolei.ru/auth/register`

1. В параметрах (*Parameters*) указываются параметры GET-запросов, передаваемые в строке запроса. У нас тут пусто.

1. Тело запроса (*Request body*). Тут указано что тело запроса обязательно должно присутсвовать (**required**) и формат `application/json`

    В теле запроса должна быть JSON-строка. Пример её можно посмотреть на вкладке **Example value**, но нам интереснее вкладка **schema** - на ней описаны типы данных (string), описание поля (что это такое вообще) и, возможно, обязательность использования поля. Например, для поля **phone** расписан шаблон, которому оно должно соответсвовать.

1. Коды ответов (*Responses*)

    Тут надо быть внимательным, коды могут отличаться.

Ну и самое приятное в **Swagger** - можно прямо в нём проверить результат работы. Кликаем кнопку "Try it out", вводим в открывшемся окне тело запроса и нажимаем выполнить (*Execute*). Таким образом нам не нужны ни **Postman** ни **VSCode** с плагинами

![](../img/mad_05.png)

Пример отправки запроса регистрации:

```kt
val json = JSONObject()
json.put("phone", phone)
json.put("password", password)
json.put("firstName", firstName)
json.put("lastName", lastName)

Http.call(
    Http.buildRequest(
        "http://carsharing.kolei.ru/auth/register",
        json.toString()
    )
) { response, error -> ... }
```

С запросом авторизации аналогично, только параметров ещё меньше.

Ответ на запрос авторизации у меня возвращает информацию о пользователе, чтобы можно было принять решение на какой экран переходить после авторизации.

![](../img/mad_06.png)

### Хранение данных в работающем приложении

Мы помним, что при пересоздании активности все её данные теряются. Нам нужно сохранить информацию о пользователе, так как остальные запросы в заголовке должны иметь токен авторизации (у меня это значение *userId*)

Теоретически можно хранить данные используя **Preferences**, но, **во-первых**, это хранилище может хранить только *скалярные* типы данных, а **во-вторых**, данные хранятся во флеш-памяти и частая её перезапись может навредить смартфону.

Есть ещё варианты: локальный сервер **SQLite** (слишком сложно для первого проекта), передача параметров через **Intent** (те же ограничения по скалярным данным), класс приложения, и механизм **ViewModel + LiveData**.

Механизм **ViewModel + LiveData** считается предпочтительным для хранения данных при работе приложения, но всё-таки сложноват для первого проекта. При желании вы можете с ним разобраться найдя статьи в интернете, например: 
* [ViewModel и LiveData. Сохранение и передача состояния активити при повороте устройства](https://www.fandroid.info/urok-7-androiddev-na-kotlin-sohranenie-i-peredacha-sostoyaniya-aktiviti-pri-povorote-ustrojstva-onsaveinstancestate-ili-viewmodel-livedata-kotlin-android-extensions/)
* [Использование ViewModel для хранения данных пользовательского интерфейса](https://swiftbook.ru/post/tutorials/android-lifecycle/)

Мы же будем использовать **хранение данных в классе приложения**.

Этот метод редко упоминается в литературе, но достаточно прост в реализации.

Рассматривая жизненный цикл андроид приложения все почему-то описывают только жизненный цикл отдельной активности (иногда ещё фрагмента), но не упоминают про само приложение. А оно между тем продолжает существовать и при смене активностей и при засыпании телефона. 

Есть возможность определить свой класс приложения и хранить в нём нужные данные, которые будут доступны в любой активности:

1. Создайте класс **MyApp**, который наследуется от класа **Application** и внутри опишите **публичные** переменные (рассмотрим на примере информации о пользователе, класс **User** реализуем ниже):

    ```kt
    class MyApp: Application() {
        var user: User? = null
    }
    ```

2. В манифесте в тег **application** добавьте атрибут `android:name=".MyApp"`, где `.MyApp` это имя созданного нами ранее класса

3. В классах, где нам нужны глобальные переменные создаем переменную, которая будет хранить указатель на **MyApp**

    ```kt
    private lateinit var app: MyApp
    ```

    В конструкторе класса проинициализируйте её

    ```kt
    app = applicationContext as MyApp
    ```

    И дальше в коде можно её использовать

    ```kt
    if(app.user?.userId != null){
        // 
    }
    ```

Класс **User** (поля берём из ответа сервера):

```kt
data class User(
    var userId: Int,
    var firstName: String,
    var lastName: String,
    var phone: String,
    var valid: Boolean,
    var avatar: String? = null,
    var prava: String? = null,
    var passport: String? = null
)
```

Поля, которые в ответе сервера не обязательны (фотографии), мы делаем *нуллабельными* и задаём значения по-умолчанию. 

Пример получения профиля:

```kt
val jsonObj = JSONObject(response.body!!.string())
app.user = User(
    jsonObj.getInt("userId"),
    jsonObj.getString("firstName"),
    jsonObj.getString("lastname"),
    jsonObj.getString("phone"),
    jsonObj.getBoolean("valid"),
    if(jsonObj.has("avatar")) jsonObj.getString("avatar") else null
)

if(jsonObj.has("prava"))
    app.user!!.prava = jsonObj.getString("avatar")
```

Обратите внимание, *нуллабельные* параметры *avatar* и *prava* я заполнил по-разному (оба варианта правильные):

* аватар мы заполнили используя возможность использовать оператор `if` как функцию
* права мы заполнили не при создании классаа, а отдельно
