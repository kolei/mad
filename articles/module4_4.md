# HTTP. Библиотеки для работы с интернет-запросами. Получение данных. Разбор JSON. Детальная информация о погоде

**API** (программный интерфейс приложения, интерфейс прикладного программирования) (англ. application programming interface, API) — описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой.

**WEB-сервер** — сервер, принимающий HTTP-запросы от клиентов и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.

**HTTP** (англ. Hyper**Text** Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

Основой **HTTP** является технология «клиент-сервер», то есть предполагается существование:

* Потребителей (клиентов), которые инициируют соединение и посылают запрос;
* Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

## Структура HTTP-сообщения

Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:

* Стартовая строка (англ. Starting line) — определяет тип сообщения;
* Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
* Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

### Стартовая строка

Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:

`Метод URI HTTP/Версия`

Здесь:

* Метод (англ. Method) — тип запроса, одно слово заглавными буквами. Cписок методов для версии 1.1 представлен ниже.
* URI определяет путь к запрашиваемому документу.
* Версия (англ. Version) — пара разделённых точкой цифр. Например: 1.0.

Чтобы запросить страницу, клиент должен передать строку (задан всего один заголовок):

```txt
GET /wiki/HTTP HTTP/1.0
Host: ru.wikipedia.org
```

Стартовая строка ответа сервера имеет следующий формат: `HTTP/Версия КодСостояния Пояснение`, где:

* Версия — пара разделённых точкой цифр, как в запросе;
* Код состояния (англ. Status Code) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;
* Пояснение (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:

```txt
HTTP/1.0 200 OK
```

### Методы

Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.

Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.

Метод **GET**

Используется для запроса содержимого указанного ресурса.

Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:

```txt
GET /path/resource?param1=value1&param2=value2 HTTP/1.1
```

Метод **POST**

Применяется для передачи пользовательских данных заданному ресурсу.

### Коды состояния

Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:

```txt
201 Webpage Created
403 Access allowed only for registered users
507 Insufficient Storage
```

### Заголовки

Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Примеры заголовков:

```txt
Server: Apache/2.2.11 (Win32) PHP/5.3.0
Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT
Content-Type: text/plain; charset=windows-1251
Content-Language: ru
```

### Тело сообщения

Тело HTTP-сообщения (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом.

## Получение информации о погоде

Для получения информации о погоде воспользуемся открытым АПИ [openweathermap](https://openweathermap.org/api)

В АПИ есть несколько вариантов: текущая погода, почасовая, на несколько дней, на месяц... Но для бесплатного использования подходят не все.

Для начала получим данные о [текущей](https://openweathermap.org/current) погоде по координатам (By geographic coordinates)

Формат запроса:

```txt
api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API key}
```

Координаты мы уже получили в предыдущем разделе, **API key** можно получить зарегистрировавшись на сайте, но можно воспользоваться моим (увидите в коде)

Дополнительно можно указать:

* **mode** - формат ответа ([**json**](https://habr.com/ru/post/554274/) или **xml**, [**json**](https://habr.com/ru/post/554274/) установлен по-умолчанию, поэтому этот параметр не трогаем; рекомендую перейти по ссылке и познакомиться с форматом [JSON](https://habr.com/ru/post/554274/))

* **units** - единицы измерения, нам нужны метрические, поэтому этот паарметр используем

* **lang** - Язык ответа. По умолчанию английский, поэтому тоже используем

В итоге получается такой URL:

```kt
val url = "https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${token}&lang=ru"
```

Проверить правильность запроса и посмотреть на результат можно запустив этот URL в **Postman**-е (он будет на демо-экзамене). Но лично мне больше нравится плагин **REST Client** для **VSCode**

Можно описать переменные и запрос в отдельном файле (например, `api.http`) и выполнять запросы прямо из **VSCode**

```txt
@lat=56.638372
@lon=47.892991
@token=d4c9eea0d00fb43230b479793d6aa78f

### Запрос текущей погоды
GET https://api.openweathermap.org/data/2.5/weather?lat={{lat}}&lon={{lon}}&units=metric&appid={{token}}&lang=ru
```

В ответ на этот запрос должно прийти что-то подобное:

```json
{
  "coord": {
    "lon": 47.893,
    "lat": 56.6384
  },
  "weather": [
    {
      "id": 802,
      "main": "Clouds",
      "description": "переменная облачность",
      "icon": "03n"
    }
  ],
  "base": "stations",
  "main": {
    "temp": -6.58,
    "feels_like": -10.63,
    "temp_min": -6.58,
    "temp_max": -6.58,
    "pressure": 1030,
    "humidity": 65,
    "sea_level": 1030,
    "grnd_level": 1018
  },
  "visibility": 10000,
  "wind": {
    "speed": 2.36,
    "deg": 236,
    "gust": 6.21
  },
  "clouds": {
    "all": 33
  },
  "dt": 1636565376,
  "sys": {
    "type": 1,
    "id": 9042,
    "country": "RU",
    "sunrise": 1636517829,
    "sunset": 1636548458
  },
  "timezone": 10800,
  "id": 466806,
  "name": "Йошкар-Ола",
  "cod": 200
}
```

В **Android**-е есть встроенные функции работы с **http**-запросами, но стандартный код для сетевых запросов сложен, излишен и в реальном мире почти не используется. Используются библиотеки. Самые популярные: [OkHttp](https://square.github.io/okhttp/) и Retrofit.

Рассмотрим работу к **OkHttp**

>[Примеры синхронных и асинхронных запросов на котлине](https://square.github.io/okhttp/recipes/)
>(я уже упоминал, что в основном потоке запускать сетевые запросы нельзя, поэтому далее мы будем работать только с асинхронными запросами)

Перед использованием не забудьте добавить в манифест разрешение на работу с интернетом

```xml
<uses-permission 
    android:name="android.permission.INTERNET" />
```

И, если на сайте нет сертификата, атрибут в тег **application** в манифесте (в нашем случае обязательно, т.к. прокси-сервер колледжа портит **https** запросы и приходится там где это возможно пользоваться **http**):

```txt
android:usesCleartextTraffic="true"
```

Ещё в зависимости проекта нужно добавить билиотеку (в файл `build.gradle(:app)` в раздел *dependencies*):

```txt
implementation 'com.squareup.okhttp3:okhttp:4.10.0'
```

>Токен объявите константой в свойствах класса
>
>```kt
>private val appid = "d4c9eea0d00fb43230b479793d6aa78f"
>```

В примерах из [OkHttp](https://square.github.io/okhttp/) нет обработки исключительных ситуаций, я написал класс обёртку, который принимает на вход строку **url** или готовый **Request** и возвращает callback с ответом или исключением (если связи физически нет или ошибка в ответе). Файл с классом лежит в каталоге [data](../data/Http.kt) этого репозитория.

Ещё, как показала практика, народ путается в коде при большой вложенности, поэтому callback лямбда-функции можно оформлять отдельными переменными, например:

```kt
private val weatherCallback: HttpCallback = {
    response, error ->
    try {
        // ошибка соединения
        if (error != null) throw error

        // если ответ получен, но код не 200, то тоже "выбрасываем" исключение
        if (!response!!.isSuccessful) throw Exception(response.message)

        // тут позже реализуем обработку результата
    } catch (e: Exception) {
        // любую ошибку показываем на экране
        showAlert(e.message ?: "какая-то ошибка")
    }
}

private fun showAlert(message: String) {
    // не забываем, что с визуальными элементами можно работать только из UI-потока
    runOnUiThread {
        AlertDialog.Builder(this)
            .setTitle("Ошибка")
            .setMessage(message)
            .setPositiveButton("OK", null)
            .create()
            .show()
    }
}
```

Теперь у нас всё готово для выполнения запроса информации о погоде. В конструкторе главного окна извлечём координаты и добавим запрос:

```kt
val lat = intent.getDoubleExtra("latitude", 0.0)
val lon = intent.getDoubleExtra("longitude", 0.0)
Http.call(
    "http://api.openweathermap.org/data/2.5/weather?lat=$latitude&lon=$longitude&units=metric&appid=$appid&lang=ru",
    weatherCallback
)
```

>Обратите внимание, хотя сервер openweathermap поддерживает **https** запросы, я посылаю **http**.

Что здесь происходит?

**Во-первых**, андроид не разрешает запускать http(s)-запросы из основного потока. Их нужно запускать асинхронно. В **OkHttp** это делает метод **enqueue** (его можно увидеть в реализации метода *call* класса **Http**).

В параметрах метода указывается *callback*-функция в виде лямбда-выражения, в котором возвращается объект ошибки при неуспешном запросе и ответ сервера. Тут нужно учитывать, что в "не успех" заворачиваются как ошибки транспортного уровня (смог **OkHttp** получить ответ сервера или нет), так и ошибки HTTP (коды 4хх и 5хх).

После разбора принятых данных их обычно выводят на экран. Тут надо учитывать что функция обратного вызова всё ещё находится в потоке, а к визуальным элементам можно обращаться только из основного потока. Для работы с визуальными элементами заворачиваем кусок кода в конструкцию:

```kt
var jsonString: String = response.body!!.string()

runOnUiThread {
    textView.text = jsonString
}
```

Сначала считываем содержимое ответа в переменную (чтение происходит из асинхронного потока), потом полученный ответ показываем на экране в UI потоке

## Разбор JSON

Как уже упоминалось, HTTP, в основном, работает с текстом. Наша переменная *jsonString* содержит JSON-строку. Для извлечения данных нужно преобразовать JSON-строку в JSON-объект.

```kt
val jsonObject = JSONObject(jsonString)
```

где, **JSONObject** конструктор, который преобразует строку в объект (т.к. JSON-строка может содержать массив или вообще скалярные данные, то для разбора строки в объект нужно применять соответствующий конструтор).

Для получения данных из JSON-объекта есть *get* методы

* *getJSONArray* - получить массив
* *getJSONObject* - получение объекта (по индексу из массива или по имени из объекта)
* *getString* - получить строку

Также есть *getInt*, *getDouble*..., доступные методы будут видны в контекстном меню.

Из полученного объекта (листинг был выше) нам нужны (эти данные вы будете выводить на экран по итогам этой лекции):

* название иконки погоды: *weather[0].icon*
* описание погоды: *weather[0].description*
* температура: *main.temp*
* влажность: *main.humidity*
* скорость (*wind.speed*) и направление (*wind.deg*) ветра
* название населенного пункта: *name*

>тут точками обозначен доступ ко вложенным свойствам: *weather[0].icon* -> "из первого элемента массива *weather* прочитать свойство *icon*"

Приведу несколько примеров:

```kt
val jsonObject = JSONObject(response.body!!.string())

// получение массива
val wheather = jsonObject.getJSONArray("weather")

// извлечение строки из первого элемента массива  
val icoName = wheather.getJSONObject(0).getString("icon")

// извлечение числа из объекта
val temp = jsonObject.getJSONObject("main").getDouble("temp")
```

## Отображение иконки

Название иконки, обозначающей погоду (солнечно, облачно, дождь...), находится в массиве *weather* - свойство *icon*

```json
"weather": [
    {
        "id": 802,
        "main": "Clouds",
        "description": "переменная облачность",
        "icon": "03n"
    }
]
```

Урл иконки формируется так (описано в АПИ):

```txt
http://openweathermap.org/img/w/{icoName}.png
```

тут в фигурных скобках текст, вместо которго должно быть вставлено имя иконки (как оно приходит в JSON)

Для загрузки картинки воспользуемся тем же методом **Http.call**:

>Вызов этого метода нужно вставить в предыдущий callback

```kt
val jsonObject = JSONObject(response.body!!.string())
val icoName = jsonObject
    .getJSONArray("weather")
    .getJSONObject(0)
    .getString("icon")

Http.call(
    "http://openweathermap.org/img/w/$icoName.png",
    icoCallback
)
```

Реализацию *icoCallback* сделаем ниже

Для отображения иконки в разметку окна добавьте элемент **ImageView**

```xml
<ImageView
    android:id="@+id/ico"
    android:layout_width="100dp"
    android:layout_height="100dp"
/>
```

Для программного отображения изображения нужно вызвать метод **setImageBitmap(Bitmap)**

Запрос иконки мы уже сделали, напишем разбор ответа:

```kt
private val icoCallback: HttpCallback = { response, error ->
    try {
        // ошибки обрабатываем всегда
        if (error != null) throw error
        if (!response!!.isSuccessful) throw Exception(response.message)

        // формирует изображение из ответа сервера
        val bitmap = BitmapFactory.decodeStream(response.body!!.byteStream())

        // задаём изображение визуальному элементу
        runOnUiThread {
            findViewById<ImageView>(R.id.icoImageView).setImageBitmap(bitmap)
        }
    } catch (e: Exception) {
        // эти ошибки не показываем, картинки вполне может и не быть
    }
}
```

## Задание

Реализовать HTTP-запрос и разбор JSON-ответа. Вывести на экран:

* иконку погоды: *weather[0].icon*
* описание погоды: *weather[0].description*
* температуру: *main.temp*
* влажность: *main.humidity*
* скорость (*wind.speed*) и направление (*wind.deg*) ветра
* название населенного пункта: *name*
