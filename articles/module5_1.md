# Разработка приложения для умных часов

В принципе тот же андроид, только с немного урезанным функционалом (список отрезанных SDK легко гуглится). Но на нашем уровне разницы практически не заметно.

## Настройка

1. Установите эмулятор для часов (**будьте внимательны, не установите китайскую версию**)

    ![](/img/as048.png)

    ![](/img/as049.png)

    ![](/img/as050.png)

    ![](/img/as051.png)

2. Создайте проект:

    ![](/img/as052.png)

## Проект "каршеринг"

Для часов корневым элементом разметки является **BoxInsetLayout** (начиная со 2-й версии). 

Внутри него расположен **FrameLayout** (это запоминать не нужно - приложение сразу таким и создаётся).

Свою разметку вы уже располагаете внутри **FrameLayout**

На демо-экзамене будет задание залогиниться на часах и показать какую-то информацию с сервера. Реализуем это на нашем API:

1. Иконку, струткуру проекта и экран заставки пропущу, но тут вы и сами должны справиться.

2. Экран авторизации (поля ввода и кнопки Login/Logout) рисуем прямо на экране **activity**

    Тут тоже сделайте сами. Отмечу только, что **activity** создается в меню ***New -> Wear -> Blank activity***

3. HTTP-запросы тоже рабтают как обычно - реализуйте только запрос login по аналогии с прошлым заданием.

    Возникли вопросы по передаче токена авторизации:

    ```kt
    Http.call(
        // т.к. у нас не простой GET по URL, то формируем запрос отдельным методом
        Http.buildRequest(
            "http://carsharing.kolei.ru/cars",
            headers = mapOf("Authorization" to "Bearer ${app.user.id}")
        )
    ) { response, error -> ... }
    ```

    У метода *buildRequest* три параметра (url, data?, headers?), но так как данных у нас в запросе нет (и они не обязательные), то параметр data мы не указываем, а чтобы компилятор понял что мы указываем не data, а headers, используем синтаксис с "именованными параметрами" (headers = ...)

    Метод *mapOf* возвращает ассоциативный список (это список пар "ключ" = "значение", где ключи должны быть уникальными). В общем виде он выглядит так:

    ```kt
    mapOf(
        "ключ1" to "значение1",
        "ключ2" to "значение2",
        ...
        "ключN" to "значениеN"
    )
    ```

4. Вывод списка автомобилей

    Для отображения списка есть свой элемент - **androidx.wear.widget.WearableRecyclerView** (позволяет прокручивать список механическим колесиком на часах и доскроливать крайние элементы до середины экрана, что очень удобно на круглых интерфейсах).

    ```kt
    wrc = findViewById(R.id.wrc)

    // этот параметр позволяет прокручивать 
    // крайние элементы списка на середину экрана 
    // (иначе на круглых часах можно не разглядеть содержимое)
    wrc.isEdgeItemsCenteringEnabled = true

    // менеждер тоже свой, но наследник старого доброго LinearLayout
    wrc.layoutManager = WearableLinearLayoutManager(this)

    // адаптер не отличается
    wrc.adapter = MyAdapter(chatList)
    ```

    Реализация адаптера не отличается от смартфона. Выведите кликабельный список автомобилей, при клике сделайте переход на детальную информацию об авто (в отдельную активности)

# Задание

Разработать приложение для **Wear OS** c несколькими экранами:

* заставка
* авторизация
* список автомобилей
* детальная информация о выбранном автомобиле
