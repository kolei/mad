# Проект "Каршеринг"

## Техническое задание

**Модуль 1** 

Разработка мобильного приложения для бронирования автомобилей (каршеринг)

Необходимо разработать мобильное приложение для смартфона, удовлетворяющее следующим требованиям:

Приложение должно поддерживать следующие версии ОС:

* Android 9.0 и новее
* iOS 13.0 и новее

В работе необходимо использовать систему контроля версий **Git**.

Необходимо загрузить результаты выполнения модуля в отдельную ветку с именем `Module_X`, где `Х` – это номер модуля. Каждый модуль должен быть в отдельном репозитории.

Необходимо корректно обрабатывать запросы к серверу. В случае получения ошибки от сервера или отсутствия соединения с сетью Интернет необходимо отобразить соответствующий текст ошибки с помощью диалогового окна.

Необходимо строго следовать предложенному дизайну. Макеты приложения доступны по ссылке:
TODO добавить ссылку на фигму

Описание протокола API доступно по ссылке:
TODO вставить ссылку на swagger

Проект приложения должен быть структурирован по экранам, то есть исходные файлы конкретного экрана должны быть в соответствующей папке. Общие для нескольких экранов классы необходимо поместить в папку `common`.

Необходимо реализовать следующий функционал:

1. Создайте проект. Настройте иконку приложения согласно макету. Следует учесть разницу в отображении иконок на различных версиях операционной системы.

2. Реализуйте экран *Launch Screen* согласно макету. Текст должен быть отдельным элементом. Логотип приложения должен быть расположен по центру экрана. При первом запуске приложения после `Launch Screen` должен отображаться `SignUp Screen`. При последующих - `SignIn Screen`.

3. Реализуйте экран `SignUp Screen` согласно макету:
    * При нажатии на кнопку "Зарегистрироваться" необходимо проверять поля для ввода на пустоту, а также телефон на корректность (требования к телефону описаны в документации к API). При некорректном заполнении необходимо отобразить ошибку с помощью диалогового окна. Так же необходимо проверять равенство пароля и его повтора.
    * При корректном заполнении формы необходимо отправлять запрос регистрации на сервер. При получении ошибки от сервера ее необходимо отобразить с помощью диалогового окна. При успешной регистрации нужно автоматически осуществить авторизацию и перейти на `Main Screen`.
    * При нажатии на кнопку "У меня уже есть аккаунт" необходимо осуществлять переход на `SignIn Screen`.
    
    * при нажатии на кнопку "Оферта" необходимо открыть web-страничку с текстом оферты, используя браузер телефона

4. Реализуйте экран `SignIn Screen` согласно макету:
    * При нажатии на кнопку "Войти" необходимо проверять поля для ввода на пустоту, а также телефон на корректность (требования к телефону описаны в документации к API). При некорректном заполнении необходимо отобразить ошибку с помощью диалогового окна. При корректном заполнении формы необходимо отправить на сервер соответствующий запрос.
    * При нажатии на кнопку "Регистрация" необходимо осуществлять переход на `SignUp Screen`.
    * При успешной авторизации необходимо осуществлять переход на экран `Main Screen` или `Profile Screen`, в зависимости от состояния пользователя (см. п.6 технического задания). При получении ошибки от сервера необходимо отобразить её с помощью диалогового окна.

5. Реализуйте экран `Profile Screen` согласно макету:
    * На экране необходимо отобразить аватарку пользователя. Рамка вокруг аватарки должна быть разного цвета в зависимости от состояния профиля:
        - *желтый*: не загружены фотографии водительских прав или паспорта
        - *красный*: есть штрафы от ГИБДД или претензии от владельца каршеринга
        - *зелёный*: всё OK (активный профиль)
    * При нажатии на кнопку "Загрузить фото водительских прав" открыть приложение "Камера" и полученную фотографию отправить на сервер.
    * При нажатии на кнопку "Загрузить файл паспорта" открыть приложение "Галерея" и выбранный файл отправить на сервер.

6. Реализуйте экран `Main Screen` согласно макету:
    * На экране необходимо отобразить google-карту с текущей позицией и маркерами автомобилей (список доступных автомобилей получить с сервера).
    * при клике на маркер автомобиля показывать краткую информацию об автомобиле (popup): марка автомобиля, фото, кнопки "забронировать" и "маршрут". Кнопка "забронировать" должна быть только у активного пользователя
    * при клике на кнопку "Забронировать" открыть окно `Booking Screen`
    * При клике на кнопку "маршрут" закрыть popup и проложить маршрут от текущей позиции пользователя до выбранного автомобиля
    * При нажатии на иконку профиля необходимо переходить на `Profile Screen`.

7. Реализуйте экран `Booking Screen` согласно макету:

## Формирование данных в JSON формате (регистрация и авторизация). Получение, хранение и применение токена авторизации (способы авторизации). LiveData, глобальные свойства в классе приложения.

Создание приложения с иконкой, репозитория и ветки для модуля 1 я расписывать не буду, с этим вы уже знакомы. 

### Хранение данных

Разберёмся как узнать: в первый раз мы запустили приложение или нет.

Подробно [тут](https://startandroid.ru/ru/uroki/vse-uroki-spiskom/73-urok-33-hranenie-dannyh-preferences.html)

Мы в качестве внешнего хранилища будем использовать **Preferences**. Это знакомый уже нам способ хранения данных в виде пары: **имя**, **значение**. Данные записываются в память телефона и доступны нам после перезапуска приложения.

Для получения экземпляра хранилища мы должны вызвать метод *getSharedPreferences*:

```kt
val myPreferences = getSharedPreferences(
    "settings", 
    MODE_PRIVATE)
```

где:
* "settings" - произвольное название вашего хранилища (их у вас может быть несколько)
* Константа MODE_PRIVATE используется для настройки доступа и означает, что после сохранения, данные будут видны только этому приложению

После получения экземпляра хранилища мы можем читать и писать в него значения.

Чтение простое:

```kt
val isFirstEnter = myPreferences
    .getBoolean(
        "isFirstEnter", 
        true)
```

Используя get-методы (*getString*, *getBoolean* и т.д.) мы можем получить сохранённые данные или значения по-умолчанию, если такого параметра нет в хранилище

Таким образом при первом входе в приложение мы получим `isFirstEnter = true`. 

Теперь нам необходимо записать в этот параметр значение `false`, чтобы при следующем входе знать, что это уже не первый вход в приложение.

Процесс записи несколько сложнее:

```kt
val editor = myPreferences.edit()
try {
    editor.putBoolean(
        "isFirstEnter", 
        false )
} finally {
    editor.commit()
}
```

Мы должны получить объект **Editor**, в котором реализованы методы сохранения данных (*putString*, *putBoolean* ...), вызвать нужный метод и после записи данных вызвать подтверждение записи в хранилище (метод *commit*)

### Регистрация и авторизация. Swagger.

**Swagger** - это фреймворк для спецификации *RESTful API*. Его прелесть заключается в том, что он дает возможность не только интерактивно просматривать спецификацию, но и отправлять запросы.

Открываем [ссылку](http://swagger.kolei.ru?url=http://carsharing.kolei.ru/swagger/carsharing.yml) на описание АПИ и смотрим что там есть:

TODO вставить картинку

В начале идёт общая информация. Нам тут пока интереснен только так называемый базовый URL. Здесь он находится в блоке Servers (`http://carsharing.areas.su`), но может быть написан и просто текстом (как базовые урлы для картинок и видео).

Дальше идут описания методов АПИ. Рассмотрим подробно метод "Регистрация":

TODO вставить картинку

1. В заголовке указано какой метод и "путь" используются для запроса. К пути надо добавить "базовый урл" и получим полный адрес запроса: `http://carsharing.kolei.ru/auth/register`

1. В параметрах (*Parameters*) указываются параметры GET-запросов, передаваемые в строке запроса. У нас тут пусто.

1. Тело запроса (*Request body*). Тут указано что тело запроса обязательно должно присутсвовать (**required**) и формат `application/json`

    В теле запроса должна быть JSON-строка. Пример её можно посмотреть на вкладке **Example value**, но нам интереснее вкладка **schema** - на ней описаны типы данных (string), описание поля (что это такое вообще) и, возможно, обязательность использования поля. Например, для поля **phone** расписан шаблон, которому оно должно соответсвовать.

1. Коды ответов (*Responses*)

    Тут надо быть внимательным, коды могут отличаться.

Ну и самое приятное в **Swagger** - можно прямо в нём проверить результат работы. Кликаем кнопку "Try it out", вводим в открывшемся окне тело запроса и нажимаем выполнить (*Execute*). Таким образом нам не нужны ни **Postman** ни **VSCode** с плагинами

TODO ![](../img/f6_007.png)

Пример отправки запроса из приложения на андроид я не привожу - вы уже должны написать его самостоятельно.






## Разбор данных в JSON формате. Получение данных из "галереи" и "камеры". Отправка **multipart** запросов