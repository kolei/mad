<!-- 4 + 2 -->

# Требования охраны труда и техники безопасности. 

1. Требования охраны труда и техники безопасности
2. Специфичные требования охраны труда, техники безопасности и окружающей среды по компетенции

# Практическое занятие на определение стартового уровня владения компетенцией.

* [Основы языка Kotlin](#основы-языка-kotlin)
    * [Изменяемые и неизменяемые переменные](#изменяемые-и-неизменяемые-переменные)
    * [Типы данных](#типы-данных)
    * [Нижние подчеркивания в числовых литералах](#нижние-подчеркивания-в-числовых-литералах)
    * [Выведение типа](#выведение-типа)
    * [Логический тип Boolean](#логический-тип-boolean)
    * [Символы (тип **Char**)](#символы)
    * [Строки (тип **String**)](#строки)
    * [Форматирование строк](#строковые-шаблоны)
    * [Тип Any](#тип-any)
    * [Операторы is и !is](#операторы-is-и-is)
    * [Null безопасность](#null-безопасность)
    * [Операции с числами](#операции-с-числами)
    * [Условные выражения](#условные-выражения)
    * [Условные конструкции](#условные-конструкции)
    * [Циклы](#циклы)
    * [Последовательности](#последовательности)
    * [Массивы](#массивы)
    * [Функции и их параметры](#функции-и-их-параметры)
    * [Лямбда-выражения](#лямбда-выражения)
    * [Функции высокого порядка](#функции-высокого-порядка)
    * [Исключения](#исключения)
* [ООП](#ооп)
    * [Конструкторы](#конструкторы)
    * [Дополнительные конструкторы](#дополнительные-конструкторы)
    * [Создание экземпляров классов](#создание-экземпляров-классов)
    * [Члены класса](#члены-класса)
    * [Наследование](#наследование)
    * [Абстрактные классы](#абстрактные-классы)
    * [Свойства и поля](#свойства-и-поля)
    * [Объявление свойств](#объявление-свойств)
    * [Свойства с отложенной инициализацией](#свойства-с-отложенной-инициализацией)
    * [Модификаторы доступа](#модификаторы-доступа)
    * [Классы данных](#классы-данных)

## Основы языка Kotlin

Для хранения данных в программе в **Kotlin**, как и в других языках программирования, применяются *переменные*. *Переменная* представляет именованный участок памяти, который хранит некоторое значение.

Каждая *переменная* характеризуется определенным **именем**, **типом данных** и **значением**. Имя переменной представляет поизвольный идентификатор, который может содержать алфавитно-цифровые символы или символ подчеркивания и должен начинаться либо с алфавитного символа, либо со знака подчеркивания. Для определения переменной можно использовать либо ключевое слово **val** (**val**ue - неизменяемое значение), либо ключевое слово **var** (**var**iable - изменяемое значение).

>Соглашение об именах переменных. Глобально распространены два варианта наименования: **camelCase** (верблюжий стиль) и **snake_case** (змеиный стиль).
>В котлине для имён переменных используется **camelCase**, а в именах файлов ресурсов **snake**.

Например, определим переменную **age**:

```kt
val age: Int
```

Вначале идет слово **val** или **var**, затем имя переменной и через двоеточие тип переменной. То есть в данном случае объявлена переменная **age**, которая имеет тип **Int**. Тип Int говорит о том, что переменная будет содержать целочисленные значения.

После определения переменной ей можно присвоить значение:

```kt
val age: Int
age = 23
```

Для присвоения значения переменной используется знак равно. Затем мы можем производить с переменной различные операции.

Присвоение значения переменной должно производиться только после ее объявления. И также мы можем сразу присвоить переменной начальное значение при ее объявлении. Такой прием называется инициализацией. При инициализации можно опустить указание типа, тип переменной будет задан по типу присваимого значения:

```kt
val age = 23 
```

### Изменяемые и неизменяемые переменные

Выше было сказано, что переменные могут объявляться как с помощью слова **val**, так и с помощью слова **var**. В чем же разница между двумя этими способами?

С помощью ключевого слова **val** определяется неизменяемая переменная (immutable variable). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:

```kt
val age: Int
age = 23        // здесь норм - первое присвоение
age = 56        // здесь ошибка - переопределить значение переменной нельзя
println(age)
```

В этом плане подобные переменные похожи на константы в других языках программирования.

А у переменной, которая определена с помощью ключевого слова **var** мы можем многократно менять значения (mutable variable):

```kt
var age: Int
age = 23
println(age)
age = 56
println(age)
```

Поэтому если не планируется изменять значение переменной в программе, то лучше определять ее с ключевым словом **val**.

### Типы данных

В **Kotlin** каждая переменная имеет определенный тип. Тип данных определяет, какие операции можно производить с данными этого типа.

В отличие от языка **Java** и ряда других языков **Kotlin** не имеет встроенных примитивных типов. Все типы представляют определенные классы.

#### Числовые типы

* **Byte**: хранит целое число от -128 до 127 и занимает 1 байт
* **Short**: хранит целое число от -32768 до 32767 и занимает 2 байта
* **Int**: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта
* **Long**: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт
* **Float**: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта
* **Double**: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байт.

#### Литералы

Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными.

Любые литералы, которые представляют целые числа, воспринимаются как данные типа Int.

```kt
val age = 45
// переменная age будет иметь тип Int
```

Литерал "45" представляет целое число и является значением типа Int. Если же мы хотим явно указать, что число представляет значение типа **Long**, то следует использовать суффикс `L`:

```kt
// тут Котлин автоматически приведет к объявленному типу
val age: Long = 45

или 

// а вот тут мы используем суффикс, чтобы явно указать тип
val age = 45L       
```

Аналогично все числа с плавающей точкой (которые содержат точку в качестве разделителя целой и дробной части) рассматриваются как числа типа **Double**:

```kt
val weight = 68.71
```

Если мы хотим указать, что данные будут представлять тип **Float**, то необходимо использовать суффикс `F`:

```kt
val weight = 68.71F
```

Кроме чисел в десятичной системе мы можем определять числа в двоичной и шестнадцатеричной системах.

Шестнадцатеричная запись числа начинается с `0x`, затем идет набор символов от `0` до `F`, которые представляют число:

```kt
val age: Int = 0x0A1    // 161
```

Двоичная запись числа предваряется символами `0b`, после которых идет последовательность из нулей и единиц:

```kt
val a = 0b0101    // 5
val b = 0b1011     // 11
```

### Нижние подчеркивания в числовых литералах

Вы можете использовать нижние подчёркивания, чтобы сделать числовые константы более читаемыми:

```kt
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### Выведение типа

**Kotlin** позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому **тип** при инициализации переменной можно опустить:

```kt
val age = 5
```

В данном случае компилятор увидит, что переменной присваивается значение типа **Int**, поэтому переменная *age* будет представлять тип **Int**.

Соответственно если мы присваиваем переменной строку, то такая переменная будет иметь тип **String**.

```kt
val name = "Tom"
```

Однако при этом нам обязательно надо инициализировать переменную некоторым значением. То есть нельзя сначала объявить переменную, а потом где-то в программе присвоить ей какое-то значение:

```kt
val age     // Ошибка, переменная не инициализирована
age = 5 
```

### Логический тип Boolean

Тип **Boolean** может хранить одно из двух значений: *true* (истина) или *false* (ложь).

```kt
val a = true
val b = false
```

### Символы

Символьные данные представлены типом **Char**. Он представляет отдельный символ, который заключается в **одинарные** кавычки.

```kt
val a = 'A'
val b = 'B'
val c = 'T'
```

Также тип **Char** может представлять специальные последовательности, которые интерпретируются особым образом:

* `\t`: табуляция
* `\n`: перевод строки
* `\r`: возврат каретки
* `\'`: одинарная кавычка
* `\"`: двойная кавычка
* `\\`: обратный слеш

### Строки

Строки представлены типом **String**. Строка представляет последовательность символов, заключенную в **двойные** кавычки, либо в тройные двойные кавычки.

```kt
val name = "Eugene"
```

Строка может содержать специальные символы или эскейп-последовательности. Например, если необходимо вставить в текст перевод на другую строку, можно использовать эскейп-последовательность `\n`:

```kt
val text = "SALT II was a series of talks between United States \n and Soviet negotiators from 1972 to 1979"
```

Для большего удобства при создании многострочного текста можно использовать тройные двойные кавычки. Такой текст воспринимается "как есть", т.е. все переносы сохраняются:

```kt
val text: String = """SALT II was a series of talks between United States
and Soviet negotiators from 1972 to 1979.
It was a continuation of the SALT I talks."""
```

Строки состоят из символов, которые могут быть получены по порядковому номеру: `someString[i]`. Проход по строке можно выполнить циклом **for**:

```kt
for (char in someString) {
    println(char)
}
```

### Строковые шаблоны

Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара (`$`) и состоит либо из простого имени (например, переменной):

```kt
val i = 10
val s = "i = $i" 
// получится "i = 10"
```

либо из произвольного выражения в фигурных скобках:

```kt
val s = "abc"
val str = "$s.length is ${s.length}" 
// получится "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости символ `$` может быть представлен с помощью следующего синтаксиса:

```kt
val price = "${'$'}9.99"
```

### Тип Any

Тип **Any** является базовым для всех остальных типов. Остальные базовые типы, такие как **Int** или **Double**, являются производными от **Any**. Соответственно мы можем присвоить переменной данного типа любое значение:

```kt
var name: Any = "Tom Smith"
name = 6758
```

### Операторы is и !is

Мы можем проверить принадлежит ли объект к какому-либо типу во время исполнения с помощью оператора **is** или его отрицания **!is**:

```kt
if (object is String) {
    print(object.length)
}

if (object !is String) { // то же самое, что и !(object is String)
    print("Not a String")
}
else {
    print(object.length)
}
```

**Умные приведения**

Во многих случаях в **Kotlin** вам не нужно использовать явные приведения, потому что компилятор следит за is-проверками для неизменяемых значений и вставляет приведения автоматически, там, где они нужны:

```kt
fun demo(x: Any) {
    if (x is String) {
        // x автоматически преобразовывается в String
        print(x.length)
    }
}
```

Компилятор достаточно умён для того, чтобы делать автоматические приведения в случаях, когда проверка на несоответствие типу (!is) приводит к выходу из функции:

```kt
if (x !is String) return

// x автоматически преобразовывается в String
print(x.length) 
```

или в случаях, когда приводимая переменная находится справа от оператора `&&` или `||`:

```kt
// x автоматически преобразовывается в String справа от `||`
if (x !is String || x.length == 0) return

// x автоматически преобразовывается в String справа от `&&`
if (x is String && x.length > 0) {
    print(x.length) // x автоматически преобразовывается в String
}
```

Заметьте, что умные приведения не работают, когда компилятор не может гарантировать, что переменная не изменится между проверкой и использованием.

**Оператор "небезопасного" приведения**

Этот оператор приведения выбрасывает исключение, если приведение невозможно, поэтому мы называем его небезопасным. Небезопасное приведение в Kotlin выполняется с помощью инфиксного оператора **as**:

```kt
val x: String = y as String
```

Заметьте, что **null** не может быть приведен к String, так как String не является nullable, т.е. если y - **null**, код выше выбросит исключение. Чтобы соответствовать семантике приведений в Java, нам нужно указать nullable тип в правой части приведения:

```kt
val x: String? = y as String?
```

### Null безопасность

#### Nullable типы и Non-Null типы

Система типов в языке **Kotlin** нацелена на то, чтобы искоренить опасность обращения к null значениям.

Самым распространённым подводным камнем многих языков программирования, в том числе **Java**, является попытка произвести доступ к **null** значению. Это приводит к ошибке. В **Java** такая ошибка называется **NullPointerException** (сокр. "NPE").

**Kotlin** призван исключить ошибки подобного рода из нашего кода. NPE могу возникать только в случае:

* Явного указания `throw NullPointerException()`
* Использования оператора `!!` (описано ниже)
* Эту ошибку вызвал внешний Java-код
* Есть какое-то несоответствие при инициализации данных (в конструкторе использована ссылка this на данные, которые не были ещё проинициализированы)

Система типов **Kotlin** различает ссылки на те, которые могут иметь значение **null** (nullable ссылки) и те, которые таковыми быть не могут (non-null ссылки). К примеру, переменная часто используемого типа **String** не может быть **null**:

```kt
var a: String = "abc"
a = null // ошибка компиляции
```

При вызове метода с использованием переменной `a`, исключены какие-либо NPE. Вы спокойно можете писать:

```kt
val l = a.length
```

Для того, чтобы разрешить **null** значение, мы можем объявить строковую переменную как `String?`:

```kt
var b: String? = "abc"
b = null // ok
```

Но в случае, если вы захотите получить доступ к значению `b`, это будет небезопасно. Компилятор предупредит об ошибке:

```kt
val l = b.length // ошибка: переменная `b` может быть null
```

Но нам по-прежнему надо получить доступ к этому свойству/значению, так? Есть несколько способов этого достичь.

#### Проверка на null

Первый способ. Вы можете явно проверить `b` на **null** значение и обработать два варианта по отдельности:

```kt
val l = if (b != null) b.length else -1
```

Компилятор отслеживает информацию о проведённой вами проверке и позволяет вызывать *length* внутри блока **if**. Также поддерживаются более сложные конструкции:

```kt
if (b != null && b.length > 0) {
    print("String of length ${b.length}")
} else {
    print("Empty string")
}
```

Обратите внимание: это работает только в том случае, если b является неизменной переменной (immutable). Например, если это локальная переменная, значение которой не изменяется в период между его проверкой и использованием. Также такой переменной может служить val. В противном случае может так оказаться, что переменная `b` изменила своё значение на null после проверки.

#### Безопасные вызовы

Вторым способом является оператор безопасного вызова `?.`:

```kt
x = b?.length
```

Этот код возвращает `b.length` в том, случае, если `b` не имеет значение **null**. Иначе он возвращает **null**. Типом этого выражения будет **Int?**.

Такие безопасные вызовы полезны в цепочках. К примеру, если Bob, Employee (работник), может быть прикреплён (или нет) к отделу Department, и у отдела может быть управляющий, другой Employee. Для того, чтобы обратиться к имени этого управляющего (если такой есть), напишем:

```kt
bob?.department?.head?.name
```

Такая цепочка вернёт **null** в случае, если одно из свойств имеет значение **null**.

Для проведения каких-либо операций исключительно над non-null значениями вы можете использовать **let** оператор вместе с оператором безопасного вызова:

```kt
val listWithNulls: List<String?> = listOf("A", null)
for (item in listWithNulls) {
    item?.let { println(it) } // выводит A и игнорирует null
}
```

#### Элвис-оператор

Если у нас есть nullable ссылка `r`, мы можем либо провести проверку этой ссылки и использовать её, либо использовать non-null значение `x`:

```kt
val l: Int = if (b != null) b.length else -1
```

Аналогом такому if-выражению является элвис-оператор **?:**:

```kt
val l = b?.length ?: -1
```

Если выражение, стоящее слева от Элвис-оператора, не является null, то элвис-оператор его вернёт. В противном случае, в качестве возвращаемого значения послужит то, что стоит справа. Обращаем ваше внимание на то, что часть кода, расположенная справа, выполняется ТОЛЬКО в случае, если слева получается null.

Так как **throw** и **return** тоже являются выражениями в **Kotlin**, их также можно использовать справа от Элвис-оператора. Это может быть крайне полезным для проверки аргументов функции:

```kt
fun foo(node: Node): String? {
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
    // ...
}
```

#### Оператор !!

Для любителей NPE существует ещё один способ. Мы можем написать `b!!` и это вернёт нам либо non-null значение `b` (в нашем примере вернётся String), либо выкинет NPE:

```kt
val l = b!!.length
```

### Операции с числами

#### Арифметические операции

**Kotlin** поддерживает базовые арифметические операции:

`+` (сложение): возвращает сумму двух чисел.

```kt
val x = 5
val y = 6
val z = x + y
println(z)      // z = 11
```

`-` (вычитание): возвращает разность двух чисел.

```kt
val x = 5
val y = 6
val z = x - y  // z = -1
```

`*` (умножение): возвращает произведение двух чисел.

```kt
val x = 5
val y = 6
val z = x * y  // z = 30
```

`/` (деление): возвращает частное двух чисел.

```kt
val x = 60
val y = 10
val z = x / y  // z = 6
```

`%`: возвращает остаток от целочисленного деления двух чисел.

```kt
val x = 65
val y = 10
val z = x % y  // z = 5
```

`++` (инкремент): увеличивает значение на единицу.

Префиксный инкремент возвращает увеличенное значение:

```
var x = 5
val y = ++x
println(x)      // x = 6
println(y)      // y = 6
```

Постфиксный инкремент возвращает значение до увеличения на единицу:

```kt
var x = 5
val y = x++
println(x)      // x = 6
println(y)      // y = 5
```

`--` (декремент): уменьшает значение на единицу.

Префиксный декремент возвращает уменьшенное значение:

```kt
var x = 5
val y = --x
println(x)      // x = 4
println(y)      // y = 4
```

Постфиксный декремент возвращает значение до уменьшения на единицу:

```kt
var x = 5
val y = x--
println(x)      // x = 4
println(y)      // y = 5
```

Также есть ряд операций присвоения, которые сочетают арифметические операции и присвоение:

`+=`: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B

`-=`: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B

`*=`: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B

`/=`: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B

`%=`: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B

### Условные выражения

Условные выражения представляют некоторое условие, которое возвращает значение типа **Boolean**: либо *true* (если условие истинно), либо *false* (если условие ложно).

#### Операции отношения

`>` (больше чем): возвращает *true*, если первый операнд больше второго. Иначе возвращает *false*

```kt
val a = 11
val b = 12
val c : Boolean =  a > b
println(c)      // false - a меньше чем b
 
val d = 35 > 12
println(d)      // true - 35 больше чем 12
```

`<` (меньше чем): возвращает true, если первый операнд меньше второго. Иначе возвращает false

```kt
val a = 11
val b = 12
val c =  a < b   // true
 
val d = 35 < 12  // false
```

`>=` (больше чем или равно): возвращает true, если первый операнд больше или равен второму

```kt
val a = 11
val b = 12
val c = a >= b      // false
val d = 11 >= a     // true
```

`<=` (меньше чем или равно): возвращает true, если первый операнд меньше или равен второму.

```kt
val a = 11
val b = 12
val c = a <= b      // true
val d = 11 <= a     // false
```

`==` (равно): возвращает true, если оба операнда равны. Иначе возвращает false

```kt
val a = 11
val b = 12
val c = a == b      // false
val d = b == 12     // true
```

`!=` (не равно): возвращает true, если оба операнда НЕ равны

```kt
val a = 11
val b = 12
val c = a != b      // true
val d = b != 12     // false
```

`in`: возвращает true, если операнд имеется в некоторой последовательности.

```kt
val a = 5
val b = a in 1..6       // true
```

>Выражение 1..6 создает последовательность чисел от 1 до 6. И в данном случае оператор `in` проверяет, есть ли значение переменной `a` в этой последовательности. Поскольку значение переменной `a` имеется в данной последовательности, то возвращается *true*.

### Условные конструкции

Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.

#### if...else

Конструкция if принимает условие, и если это условие истинно, то выполняется последующий блок инструкций.

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
```

В данном случае в конструкции *if* проверяется истинность выражения `a == 10`, если оно истинно, то выполняется последующий блок кода в фигурных скобках, и на консоль выводится сообщение "a равно 10". Если же выражение ложно, тогда блок кода не выполняется.

Если необходимо задать альтернативный вариант, то можно добавить блок *else*:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else{
    println("a НЕ равно 10")
}
```

Таким образом, если условное выражение после оператора *if* истинно, то выполняется блок после *if*, если ложно - выполняется блок после *else*.

Если блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:

```kt
val a = 10
if(a == 10)
    println("a равно 10")
else
    println("a НЕ равно 10")
```

Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения `else if`:

```kt
val a = 10
if(a == 10) {
    println("a равно 10")
}
else if(a == 9){
    println("a равно 9")
}
else if(a == 8){
    println("a равно 8")
}
else{
    println("a имеет неопределенное значение")
}
```

Стоит отметить, что конструкция *if* может возвращать значение. Например, найдем максимальное из двух чисел:

```kt
val a = 10
val b = 20
val c = if (a > b) a else b
 
println(c)  // 20
```

Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:

```kt
val a = 10
val b = 20
val c = if (a > b){
    println("a = $a")
    a
} else {
    println("b = $b")
    b
}
```

В конце каждого блока указывается возвращаемое значение.

#### Конструкция when

Конструкция **when** проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция **when** аналогична конструкции **switch** в других языках.

```kt
val a = 10
when (a) {
    10 -> println("a = 10")
    20 -> println("a = 20")
    else -> println("неопределенное значение")
}
```

После ключевого слова **when** в скобках идет выражение. Затем идет блок кода, в котором определяются значения для сравнения. После каждого значения после стрелки `->` идет последовательность выполняемых инструкций:

```kt
10 -> println("a = 10")
```

То есть в данном случае если переменная `a` равна 10, то на консоль будет выводиться сообщение "a = 10".

Если ни одно из значений в блоке **when** не соответствуют выражению, то выполняются инструкции из выражения **else**. Выражение **else** не обязательное, его можно не определять.

Если надо, чтобы при совпадении значений выполнялось несколько инструкций, то для каждого значения можно определить блок кода:

```kt
var a = 10
when (a) {
    10 -> {
        println("a = 10")
        a *= 2
    }
    20 -> {
        println("a = 20")
        a *= 5
    }
    else -> { println("неопределенное значение")}
}
println(a)
```

Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:

```kt
val a = 10
when (a) {
    10, 20 -> println("a = 10 или a = 20")
    else -> println("неопределенное значение")
}
```

Также можно сравнивать с целым диапазоном значений с помощью оператора `in`:

```kt
val a = 10
when(a){
    in 10..19 -> println("a в диапазоне от 10 до 19")
    in 20..29 -> println("a в диапазоне от 20 до 29")
    !in 10..20 -> println("a вне диапазона от 10 до 20")
    else -> println("неопределенное значение")
}
```

Если оператор `in` позволяет узнать, есть ли значение в определенном диапазоне, то связка операторов `!in` позволяет проверить отсутствие значения в определенной последовательности.

##### Возвращение значения

Как и **if** конструкция **when** может возвращать значение:

```kr
val sum = 1000
 
val rate = when(sum){
    in 100..999 -> 10
    in 1000..9999 -> 15
    else -> 20
}
println(rate)       // 15
```

Таким образом, если значение переменной *sum* располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.

Также вместе с **when**-выражениями работают умные приведения (is, !is)

```kt
when (x) {
    is Int -> print(x + 1)
    is String -> print(x.length + 1)
    is IntArray -> print(x.sum())
}
```

**when** удобно использовать вместо цепочки условий вида `if-else if`. При отстутствии аргумента, условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

```kt
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

### Циклы

Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз.

#### For

Цикл **for** пробегается по всем элементам коллекции. В этом плане цикл **for** в **Kotlin** эквивалентен циклу **for-each** в ряде других языков программирования. Его формальная форма выглядит следующим образом:

```kt
for(переменная in поледовательность){
    выполняемые инструкции
}
```

Например, выведем все квадраты чисел от 1 до 9, используя цикл for:

```kt
for(n in 1..9){
    print("${n * n} \t")
}
```

В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную `n`. И через переменную `n` можно манипулировать значением элемента. То есть в данном случае мы получим следующий консольный вывод:

```
1 	4 	9 	16 	25 	36 	49 	64 	81
```

Циклы могут быть вложенными. Например, выведем таблицу умножения:

```kt
for(i in 1..9){
    for(j in 1..9){
        print("${i * j} \t")
    }
    println()
}
```

В итоге на консоль будет выведена следующая таблица умножения:

```
1 	2 	3 	4 	5 	6 	7 	8 	9 	
2 	4 	6 	8 	10 	12 	14 	16 	18 	
3 	6 	9 	12 	15 	18 	21 	24 	27 	
4 	8 	12 	16 	20 	24 	28 	32 	36 	
5 	10 	15 	20 	25 	30 	35 	40 	45 	
6 	12 	18 	24 	30 	36 	42 	48 	54 	
7 	14 	21 	28 	35 	42 	49 	56 	63 	
8 	16 	24 	32 	40 	48 	56 	64 	72 	
9 	18 	27 	36 	45 	54 	63 	72 	81
```

#### Цикл while

Цикл **while** повторяет определенные действия пока истинно некоторое условие:

```kt
var i = 10
while(i > 0){
    println(i*i)
    i--;
}
```

Здесь пока переменная `i` больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения `i`.

В данном случае вначале проверяется условие (i > 0) и если оно истинно (то есть возвращает true), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная i изначально меньше 0, тогда цикл вообще не будет выполняться.

Но есть и другая форма цикла while - `do..while`:

```kt
var i = -1
do{
    println(i*i)
    i--;
}
while(i > 0)
```

В данном случае вначале выполняется блок кода после ключевого слова **do**, а потом оценивается условие после **while**. Если условие истинно, то повторяется выполнение блока после **do**. То есть несмотря на то, что в данном случае переменная `i` меньше 0 и она не соответствует условию, тем не менее блок **do** выполнится хотя бы один раз.

#### Операторы continue и break

Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор **continue**:

```kt
for(n in 1..8){
    if(n == 5) continue;
    println(n * n)
}
```

В данном случае когда `n` будет равно 5, сработает оператор **continue**. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве

Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор **break**:

```kt
for(n in 1..5){
    if(n == 5) break;
    println(n * n)
}
```

В данном случае когда `n` окажется равен 5, то с помощью оператора **break** будет выполнен выход из цикла. Цикл полностью завершится.

### Последовательности

Последовательность представляет набор значений или диапазон. Для создания последовательности применяется оператор `..`:

```kt
var range = 1..5    // последовательность [1, 2, 3, 4, 5]
```

Этот оператор принимает два значения - границы последовательности, и все элементы между этими значениями (включая их самих) составляют последовательность.

Последовательность необязательно должна представлять числовые данные. Например, это могут быть строки:

```kt
var range =  "a".."d"
```

Оператор `..` создаёт последовательность по нарастающей, где каждый следующий элемент будет больше предыдущего. С помощью специальной функции **downTo** можно построить последовательность в обратном порядке:

```kt
var range1 =  1..5      // 1 2 3 4 5
var range2 =  5 downTo 1    // 5 4 3 2 1
```

Еще одна специальная функция **step** позволяет задать шаг, на который будут изменяться последующие элементы:

```kt
var range1 = 1..10 step 2           // 1 3 5 7 9
var range2 = 10 downTo 1 step 3     // 10 7 4 1
```

Еще одна функция **until** позволяет не включать верхнюю границу в саму последовательность:

``` kt
var range1 = 1 until 9          // 1 2 3 4 5 6 7 8
var range2 = 1 until 9 step 2   // 1 3 5 7
```

С помощью специальных операторов можно проверить наличие или отсутствие элементов в последовательности:

**in**: возвращает true, если объект имеется в последовательности

**!in**: возвращает true, если объект отсутствует в последовательности

```kt
fun main(args: Array<String>) {
     var range = 1..5
 
    var isInRange = 5 in range
    println(isInRange)      // true
 
    isInRange = 86 in range
    println(isInRange)      // false
 
    var isNotInRange = 6 !in range
    println(isNotInRange)   // true
 
    isNotInRange = 3 !in range
    println(isNotInRange)   // false
}
```

С помощью цикла **for** можно перебирать последовательность:

```kt
var range1 = 5 downTo 1 
for(c in range1) print(c)   // 54321
println()
for(c in 1..9) print(c)     // 123456789
println()
for(c in 1 until 9) print(c)    // 12345678
println()
for(c in 1..9 step 2) print(c)  // 13579
```

### Массивы

Массив представляет набор данных одного типа. В языке **Kotlin** массивы представлены типом **Array**.

При определении массива после типа **Array** в угловых скобках необходимо указать, объекты какого типа могут храниться в массиве. Например, определим массив целых чисел:

```kt
val numbers: Array<Int>
```

С помощью встроенной функции *arrayOf()* можно передать набор значений, которые будут составлять массив:

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
```

То есть в данном случае в массиве 5 чисел от 1 до 5.

С помощью индексов мы можем обратиться к определенному элементу в массиве. Индексация начинается с нуля, то есть первый элемент буде иметь индекс 0. Индекс указывается в квадратных скобках:

```kt
val numbers = arrayOf(1, 2, 3, 4, 5)
val n = numbers[1]  // получаем второй элемент  n=2
numbers[2] = 7      // переустанавливаем третий элемент
```

Также инициализировать массив значениями можно следующим способом:

```kt
val numbers = Array(3, {5}) // [5, 5, 5]
```

Здесь применяется конструктор класса **Array**. В этот конструктор передаются два параметра. Первый параметр указывает, сколько элементов будет в массиве. В данном случае 3 элемента. Второй параметр представляет выражение, которое генерирует элементы массива. Оно заключается в фигурные скобки. В данном случае в фигурных скобках стоит число 5, то есть все элементы массива будут представлять число 5. Таким образом, массив будет состоять из трех пятерок.

Для упрощения создания массива в **Kotlin** определены дополнительные типы **BooleanArray**, **ByteArray**, **ShortArray**, **IntArray**, **LongArray**, **CharArray**, **FloatArray** и **DoubleArray**, которые позволяют создавать массивы для определенных типов. Например, тип **IntArray** позволяет определить массив объектов **Int**, а **DoubleArray** - массив объектов **Double**:

```kt
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5)
val doubles: DoubleArray = doubleArrayOf(2.4, 4.5, 1.2)
```

Для определения данных для этих массивов можно применять функции, которые начинаются на название типа в нижнем регистре, например, int, и затем идет ArrayOf.

Аналогично для инициализации подобных массивов также можно применять конструктор соответствуюшего класса:

```kt
val numbers = IntArray(3, {5})
val doubles = DoubleArray(3, {1.5})
```

Как и в случае с последовательностью мы можем проверить наличие или отсутствие элементов в массиве с помощью операторов **in** и **!in**:

```kt
val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)
 
println(4 in numbers)       // true
println(2 !in numbers)      // false
```

#### Двухмерные массивы

Выше рассматривались одномерные массивы, которые можно представить в виде ряда или строки значений. Но кроме того, мы можем использовать многомерные массивы. К примеру, возьмем двухмерный массив - то есть такой массив, каждый элемент которого в свою очередь сам является массивом. Двухмерный массив еще можно представить в виде таблицы, где каждая строка - это отдельный массив, а ячейки строки - это элементы вложенного массива.

Определение двухмерных массивов менее интуитивно понятно и может вызывать сложности. Например, двухмерный массив чисел:

```kt
val table: Array<Array<Int>> = Array(3, { Array(5, {0}) })
```

В данном случае двухмерный массив будет иметь три элемента - три строки. Каждая строка будет иметь по пять элементов, каждый из которых равен 0.

Используя индексы, можно обращаться к подмассивам в подобном массиве, в том числе переустанавливать их значения:

```kt
val table = Array(3, { Array(3, {0}) })
table[0] = arrayOf(1, 2, 3)
table[1] = arrayOf(4, 5, 6)
table[2] = arrayOf(7, 8, 9)
```

Для обращения к элементам подмассивов двухмерного массива необходимы два индекса. По первому индексу идет получение строки, а по второму индексу - столбца в рамках этой строки:

```kt
val table = Array(3, { Array(3, {0}) })
table[0][1] = 6  // второй элемент первой строки
val n = table[0][1]     // n = 6
```

#### Перебор массивов

Для перебора массивов применяется цикл **for**:

```kt
val phones: Array<String> = arrayOf("Galaxy S8", "iPhone X", "Motorola C350")
for(phone in phones){
    println(phone)
}
```

В данном случае переменная phones представляет массив строк. При переборе этого массива в цикле каждый его элемент оказывается в переменной phone. Консольный вывод программы:

```
Galaxy S8
iPhone X
Motorola C350
```

Используя два цикла, можно перебирать двухмерные массивы:

```kt
fun main(args: Array<String>) {
    val table: Array<Array<Int>> = Array(3, { Array(3, {0}) })
    table[0] = arrayOf(1, 2, 3)
    table[1] = arrayOf(4, 5, 6)
    table[2] = arrayOf(7, 8, 9)
    for(row in table){
        for(cell in row){
            print("$cell \t")
        }
        println()
    }
}
```

С помощью внешнего цикла for(row in table) пробегаемся по всем элементам двухмерного массива, то есть по строкам таблицы. Каждый из элементов двухмерного массива сам представляет массив, поэтому мы можем пробежаться по этому массиву и получить из него непосредственно те значения, которые в нем хранятся. В итоге на консоль будет выведено следующее:

```
1 	2 	3 	
4 	5 	6 	
7 	8 	9
```

#### Сортировка элементов массива

В **Kotlin** очень просто сортировать элементы.

Для этого используется метод **sort()**. При этом мы меняем существующий массив, а не создаём новый.

```kt
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
numbers.sort()
println(Arrays.toString(numbers))
```

Так же есть сортировка в обратном порядке от наибольшего значения к наименьшему.

```kt
numbers.sortDescending()
```

Для сортировки массива объектов указываем компаратор и условие сравнения. Например, мы хотим сравнить котов по их возрастам.

```kt
data class Cat(val name: String, val age: Int)

val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))

// сортируем по возрасту
cats.sortWith(Comparator { c1: Cat, c2: Cat -> c1.age - c2.age })
```

Вместо компаратора можно использовать функцию sortBy() с указанием условия. Сравним теперь котов не по возрасту, а по их именам.

```kt
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))

cats.sortBy { cat -> cat.name }
```

#### Методы массивов

**contains** - содержится ли элемент в массиве

>Если содержится, то возвращает true.

```kt
val array = arrayOf(1, 2, 3, 4, 5)
val isContains = array.contains(9) // false
```

Агрегатные методы **average** (среднее), **sum**, **min**, **max**, **length**

### Функции и их параметры

Одним из строительных блоков программы являются функции. Функция определяет некоторое действие. В Kotlin функция объявляется с помощью ключевого слова **fun**, после которого идет название функции. Затем после названия в скобках указывается список параметров. Если функция возвращает какое-либо значение, то после списка параметров через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции.

```
fun имя_функции (параметры) : возвращаемый_тип 
{
    выполняемые инструкции
}
```

Параметры необязательны.

Например, определим и вызовем функцию, которая просто выводит некоторую строку на консоль:

```kt
fun main(args: Array<String>) {
    hello() // вызов функции hello
    hello() // вызов функции hello
    hello() // вызов функции hello
}

// определение функции hello
fun hello(){
    println("Hello")
}
```

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция main. Такие функции еще называют функциями верхнего уровня (top-level functions).

Здесь кроме главной функции main также определена функция hello, которая не принимает никаких параметров и ничего не возвращает. Она просто выводит строку на консоль.

Функция hello (и любая другая определенная функция, кроме main) сама по себе не выполняется. Чтобы ее выполнить, ее надо вызвать. Для вызова функции указывается ее имя (в данном случае "hello"), после которого идут пустые скобки.

Таким образом, если необходимо в разных частях программы выполнить одни и те же действия, то можно эти действия вынести в функцию, и затем вызывать эту функцию.

#### Предача параметров

Через параметры функция может получать некоторые значения извне. Параметры указываются после имени функции в скобках через запятую в формате имя_параметра : тип_параметра. Например, определим функцию, которая вычисляет факториал числа:

```kt
fun main(args: Array<String>) {
    factorial(4)
    factorial(5)
    factorial(6)
}
 
fun factorial(n: Int){
 
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    println("Factorial of $n is equal to $result")
}
```

Функция factorial принимает один параметр типа Int. Поэтому при вызове функции в скобках необходимо передать значение для этого параметра: factorial(4). Причем это значение должно представлять тип Int. Значения, которые передаются параметрам функции, еще назвают аргументами.

Консольный вывод программы:

```
Factorial of 4 is equal to 24
Factorial of 5 is equal to 120
Factorial of 6 is equal to 720
```

Другой пример - функция, которая выводит данные о пользователе на консоль:

```kt
fun main(args: Array<String>) {
    displayUser("Tom", 23)
    displayUser("Alice", 19)
    displayUser("Kate", 25)
}

fun displayUser(name: String, age: Int){
    println("Name: $name   Age: $age")
}
```

Функция displayUser() принимает два параметра - name и age. При вызове функции в скобках ей передаются значения для этих параметров. При этом значения передаются параметрам по позиции и должны соответствовать параметрам по типу. Так как вначале идет параметр типа String, а потом параметр типа Int, то при вызове функции в скобках вначале передается строка, а потом число.

#### Аргументы по умолчанию

В примере выше при вызове функций factorial и displayUser мы обязательно должны предоставить для каждого их параметра какое-то определенное значение, которое соответствует типу параметра. Мы не можем, к примеру, вызвать функцию displayUser, не передав ей аргументы для параметров, это будет ошибка.

Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:

```kt
fun displayUser(name: String, age: Int = 18, position: String="unemployed"){
    println("Name: $name   Age: $age  Position: $position")
}
 
fun main(args: Array<String>) {
    displayUser("Tom", 23, "Manager")
    displayUser("Alice", 21)
    displayUser("Kate")
}
```

В данном случае функция displayUser имеет три параметра для передачи имени, возраста и должности. Для первого параметр name значение по умолчанию не установлено, поэтому для него по-прежнему обязательно передавать значение. Два последующих - age и position являются необязательными, и для них установлено значение по умолчанию. Если для этих параметров не передаются значения, тогда параметры используют значения по умолчанию. Поэтому для этих параметров в принципе нам необязательно передавать аргументы. Но если для какого-то параметра определено значение по умолчанию, то для всех последующих параметров тоже должно быть установлено значение по умолчанию.

Консольный вывод программы

```
Name: Tom   Age: 23  Position: Manager
Name: Alice   Age: 21  Position: unemployed
Name: Kate   Age: 18  Position: unemployed
```

#### Именованные аргументы

По умолчанию значения передаются параметрам по позиции: первое значение - первому параметру, второе значение - второму параметру и так далее. Однако, используя именованные аргументы, мы можем переопределить порядок их передачи параметрам:

```kt
fun main(args: Array<String>) {
    displayUser(name="Tom", position="Manager", age=28)
    displayUser(age=21, name="Alice")
    displayUser("Kate", position="Middle Developer")
}
```

При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать ему нужное значение.

При этом, как видно из последнего случае, необязательно все аргументы передавать по имени. Часть аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то остальные также должны передаваться по имени соответствующих параметров.

#### Возвращение результата. Оператор return

Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение.

Например, определим функцию, которая возвращает факториал числа:

```kt
fun factorial(n: Int) : Int
{ // функция возвращает значение типа Int
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    return result       //  возвращение значения
}
 
fun main(args: Array<String>) 
{
    val a = factorial(4)
    val b = factorial(5)
    val c = factorial(6)
    println("a=$a  b=$b  c=$c")
}
```

В объявлении функции factorial после списка параметров через двоеточие указывается тип Int, который будет представлять тип возвращаемого значения.

Так как функция возвращает значение, то при ее вызове это значение можно присвоить переменной:

```kt
val a = factorial(4)
```

#### Тип Unit

Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа **Unit**. Этот тип аналогичен типу **void** в ряде языков программирования, которое указывает, что функция ничего не возвращает. Например, следующая функция

```kt
fun hello()
{
    println("Hello")
}
```

будет аналогична следующей:

```kt
fun hello() : Unit
{
    println("Hello")
}
```

Формально мы даже можем присвоить результат такой функции переменной:

```kt
val d = hello()
val e = hello()
```

Однако практического смысла это не имеет, так как возвращаемое значение представляет объект Unit, который больше никак не применяется.

Если функция возвращает значение Unit, мы также можем использовать оператор return для возврата из функции:

```kt
fun factorial(n: Int){
    if(n < 1){
        println("Incorrect input parameter")
        return
    }
    var result = 1;
    for(d in 1..n){
        result *= d
    }
    println("Factorial of $n is equal $result")
}
```

В данном случае если значение параметра n меньше 1, то с помощью оператора return осуществляется выход из функции, и последующие инструкции не выполняются. При этом если функция возвращает значение Unit, то после оператора return можно не указывать никакого значения.

#### Область действия функций

В Kotlin функции могут быть объявлены в самом начале файла. Подразумевается, что вам не обязательно создавать объект какого-либо класса, чтобы воспользоваться его функцией (как в Java, C# или Scala). В дополнение к этому, функции в языке Kotlin могут быть объявлены локально, как функции-члены (ориг. "member functions") и функции-расширения ("extension functions").

#### Локальные функции

Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.

Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.

Например, функция принимает на вход основание и высоту двух треугольников и должна вычислить, больше ли площадь первого треугольника, чем второго:

```kt
fun isFirstGreater(base1: Double, height1: Double, base2: Double, height2: Double): Boolean{
 
    fun square(base: Double, height: Double) = base * height / 2
     
    return square(base1, height1) > square(base2, height2)
}

fun main(args: Array<String>) {
    val a = isFirstGreater(10.0, 10.0, 20.0, 20.0)
    val b = isFirstGreater(20.0, 20.0, 10.0, 10.0)
    println("a=$a  b=$b")
}
```

Для промежуточных вычислений - вычисления площади каждого отдельного треугольника в функции isFirstGreater определена вспомогательная функция square. Больше в программе эта функция нигде не используется, поэтому ее можно сделать локальной.

При этом локальная может использоваться только в той функции, где она определена.

### Лямбда-выражения

Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды могут передаваться в качестве параметра в функции.

Лямбда-выражения оборачиваются в фигурные скобки:

```kt
{println("hello")}
```

В данном случае лямбда-выражение выводит на консоль строку "hello".

Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию.

```kt
fun main(args: Array<String>) {
 
    val hello = {println("hello")}
    hello()
    hello()
}
```

В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза.

Также лямбда-выражение можно выполнить сразу при определении с помощью оператора run:

```kt
fun main(args: Array<String>) 
{
    run {println("hello")}
}
```

#### Передача параметров

Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка `->`. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.

```kt
fun main(args: Array<String>) 
{
    val printer = {message: String -> println(message)}
    printer("Hello")
    printer("Good Bye")
}
```

Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль.

Если параметров несколько, то они передаются слева от стрелки через запятую:

```kt
fun main(args: Array<String>) 
{
    val sum = {x:Int, y:Int -> println(x + y)}
    sum(2, 3)   // 5
    sum(4, 5)   // 9
}
```

Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:

```kt
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
}
```

#### Возвращение результата

Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной.

Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:

```kt
val hello = { println("Hello")}
val h = hello()             // h представляет тип Unit
 
val printer = {message: String -> println(message)}
val p = printer("Welcome")    // p представляет тип Unit
```

В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа Unit).

Но также может возвращаться конкретное значение:

```kt
fun main(args: Array<String>) {
 
    val sum = {x:Int, y:Int -> x + y}
     
    val a = sum(2, 3)   // 5
    val b = sum(4, 5)   // 9
    println("a=$a  b=$b")
}
```

Здесь выражение справа от стрелки x + y продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной.

Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:

```kt
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
    result
}
```

Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения.

### Функции высокого порядка

Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.

#### Тип функции

Для определения функций высокого порядка прежде всего необходимо представлять, что такое тип функции. Тип функции определяется следующим образом:

```
(типы_параметров) -> возвращаемый_тип
```

Например, возьмем следующее лямбда-выражение:

```
{mes: String-> println(mes)}
```

Это лямбда-выражение принимает в качестве параметра строку и формально ничего не возвращает (точнее возвращаемым типом является Unit). Поэтому тип этого выражения будет следующий:

```
(String)-> Unit
```

Другой пример: лямбда-выражение принимает два числа и возвращает их сумму:

```
x: Int, y: Int -> x+y
```

Это выражение будет иметь следующий тип:

```
(Int, Int) -> Int
```

Если лямбда-выражение не принимает никаких параметров, то указываются пустые скобки:

```
() -> Unit
```

К примеру, этому типу будет соответствовать лямбда-выражение {println("hello")}

При определении лямбда-выражения и присвоении его переменной мы можем явным образом у этой переменной указать тип:

```kt
val sum: (Int, Int)-> Int = {x:Int, y: Int -> x+y}
val printer: (String) -> Unit = {message: String -> println(message)}
```

Правда, в данном случае тип можно не указывать, так как компилятор может сам вывести тип переменной.

#### Передача лямбда-выражения в функцию

Для передачи лямбда-выражения в функцию, необходимо определить у функции параметр, тип которого соответствует типу лямбда-выражения:

```kt
fun main(args: Array<String>) {
 
    val add = {x:Int, y: Int -> x+y}
    val multiply = {x:Int, y: Int -> x*y}
 
    action(5, 3, add)
    action(5, 3, multiply)
    action(5, 3, {x: Int, y: Int -> x -y})
}
 
fun action (n1: Int, n2: Int, operation: (Int, Int)-> Int){
    val result = operation(n1, n2)
    println(result)
}
```

В данном случае функция action определяет три параметра. Первый два параметра - числа, а третий параметр - некоторая операция, которая производится над этими числами. На момент определения функции можно не знать, что это будет за операция. Это может быть любое лямбда-выражение, которое принимает два объекта типа Int и возвращает также объект типа Int.

В самой функции action вызываем эту операцию, передавая ей два числа, и полученный результат выводим на консоль.

При вызове функции action мы можем передать для ее третьего параметра лямбда-выражение, которое соответствует этому параметру по типу:

```kt
action(5, 3, add)
action(5, 3, multiply)
action(5, 3, {x: Int, y: Int -> x -y})
```

#### Возвращение функции из функции

В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:

```kt
fun selectAction(key: Int): (Int, Int) -> Int
{
    // определение возвращаемого результата
    when(key){
        1 -> return {x:Int, y: Int -> x + y}
        2 -> return {x:Int, y: Int -> x - y}
        3 -> return {x:Int, y: Int -> x * y}
        else -> return  {x:Int, y: Int -> 0}
    }
}
```

Здесь функция selectAction принимает один параметр - key, который представляет тип Int. В качестве возвращаемого типа у функции указан тип (Int, Int) -> Int. То есть selectAction будет возвращать некую функцию, которая принимает два параметра типа Int и возвращает объект типа Int.

В теле функции selectAction в зависимости от значения параметра key возвращается определенное лямбда-выражение, которое соответствует типу (Int, Int) -> Int.

Используем данную функцию:

```kt
fun main(args: Array<String>) 
{
    var action = selectAction(1)
    println(action(8,5))    // 13
 
    action = selectAction(2)
    println(action(8,5))    // 3
}

fun selectAction(key: Int): (Int, Int) -> Int
{
    // определение возвращаемого результата
    when(key){
        1 -> return {x:Int, y: Int -> x + y}
        2 -> return {x:Int, y: Int -> x - y}
        3 -> return {x:Int, y: Int -> x * y}
        else -> return  {x:Int, y: Int -> 0}
    }
}
```

Здесь переменная action хранит результат функции selectAction. Так как selectAction возвращает лямбда-выражение, то и переменная action будет хранить определенное лямбда-выражение. Затем через переменную action можно вызвать это лямбда-выражение. Поскольку лямбда-выражение соответствует типу (Int, Int) -> Int, то при его вызове ему необходимо передать два числа и соответственно мы можем получить его результат и вывести его на консоль.

### Исключения

В любой, особенно большой, программе могут возникать ошибки, приводящие к её неработоспособности или к тому, что программа делает не то, что должна. Причин возникновения ошибок много.

Программист может сделать ошибку в употреблении самого языка программирования. Другими словами, выразиться так, как выражаться не положено. Например, начать имя переменной с цифры или забыть поставить двоеточие в заголовке сложной инструкции. Подобные ошибки называют синтаксическими, они нарушают синтаксис и пунктуацию языка. IDE, встретив ошибочное выражение, не знает как его интерпретировать. Поэтому  выводит соответствующее сообщение, указав на место возникновения ошибки.

Но случаются ошибки, которые происходят во время выполнения программы, например, деление на 0 или попытка открыть несуществующий файл. В таких случаях JVM "выбрасывает" исключение.

На этот случай в языках программирования, в том числе Котлин, существует специальный оператор, позволяющий перехватывать возникающие исключения и обрабатывать их так, чтобы программа продолжала работать или корректно завершала свою работу.

#### Классы исключений

Все исключения в Kotlin являются наследниками класса **Throwable**. У каждого исключения есть сообщение, трассировка стека, а также причина, по которой это исключение вероятно было вызвано.

Обычно исключения вызываются системой (деление на 0, попытка открыть не существующий файл...), но можно и самому возбудить исключение явным образом, для этого используется оператор **throw**

```kt
throw MyException("Hi There!")
```

#### try

Оператор **try** позволяет перехватывать исключения

```kt
try {
    // при возникновении исключения в этом блоке кода выполнение программы перейдет в блок catch
}
catch (e: SomeException) {
    // handler
}
catch (e: AnotherException) {
    // handler
}
finally {
    // этот блок выполнится всегда
}
```

После блока **try** может быть любое количество блоков **catch** (такие блоки могут и вовсе отсутствовать). Блоки **finally** могут быть опущены. Однако, должен быть использован как минимум один блок catch или finally.

#### Try - это выражение

Ключевое слово try является выражением, то есть оно может иметь возвращаемое значение.

```kt
val a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }
```

Возвращаемым значением будет либо последнее выражение в блоке try, либо последнее выражение в блоке catch (или блоках). Содержимое finally блока никак не повлияет на результат try-выражения.

## ООП

Язык Котлин – типичный представитель ООП-семейства, обладающий элегантной и мощной объектной моделью. В этом языке от объектов никуда не спрятаться (ведь даже числа являются ими), поэтому давайте разбираться, как это все реализовано.

Классы в Kotlin объявляются с помощью использования ключевого слова **class**:

```kt
class Transformer {}
```

Объявление класса состоит из ключевого слова **class**,  имени класса (помним, что в котлине названия типов данных начинаются с большой буквы), заголовка (указания типов его параметров, основного конструктора и т.п) и тела класса, заключённого в фигурные скобки. И заголовок, и тело класса являются необязательными составляющими: если у класса нет тела, фигурные скобки могут быть опущены.

```kt
class Empty
```

### Конструкторы

Конструктор - это метод, который будет выполнен при создании экземпляра класса. В нем, обычно, производится инициализация данных.

Класс в Kotlin может иметь основной конструктор (**primary constructor**) и дополнительные конструкторы (**secondary constructors**). Основной конструктор является частью заголовка класса, его объявление идёт сразу после имени класса (и необязательных параметров):

```kt
class Transformer constructor(firstName: String)
```

Если у конструктора нет аннотаций и модификаторов видимости, ключевое слово *constructor* может быть опущено:

```kt
class Transformer(firstName: String)
```

Основной конструктор **не может** содержать в себе исполняемого кода. Инициализирующий код может быть помещён в соответствующий блок (**initializers blocks**), который помечается словом init:

```kt
class Transformer(name: String) {
    init {
        logger.info("Transformer initialized with value ${name}")
    }
}
```

Обратите внимание, что параметры основного конструктора фактически являются свойствами класса и могут быть использованы в его методах и других свойствах:

```kt
class Transformer(name: String) {
    val transformerAlias = name.toUpperCase()
}
```

В действительности, для объявления и инициализации свойств основного конструктора в Kotlin есть лаконичное синтаксическое решение:

```kt
class Transformer(val firstName: String, val lastName: String, var age: Int) {
  // ...
}
```

### Дополнительные конструкторы

В классах также могут быть объявлены дополнительные конструкторы (**secondary constructors**), перед которыми используется ключевое слово **constructor**:

```kt
class Transformer {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
```

Если у класса есть основной конструктор, каждый дополнительный конструктор должен прямо или косвенно ссылаться (через другой(ие) конструктор(ы)) на основной:

```kt
class Transformer(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
```

### Создание экземпляров классов

Для создания экземпляра класса конструктор вызывается так, как если бы он был обычной функцией:

```kt
val transformer = Transformer()

val Transformer2 = Transformer("Joe Smith")
```

### Члены класса

Классы могут содержать в себе:

* Конструкторы и инициализирующие блоки
* Функции
* Свойства
* Вложенные классы
* Объявления объектов

### Наследование

Для всех классов в языке Koltin родительским суперклассом является класс **Any**. Он также является родительским классом для любого класса, в котором не указан какой-либо другой родительский класс:

```kt
class Example // Неявно наследуется от Any
```

Класс **Any** не является аналогом `java.lang.Object`. В частности, у него нет никаких членов кроме методов: equals(), hashCode(), и toString(). 

Для явного объявления предка, от которого наследуемся, мы помещаем его имя за знаком двоеточия в оглавлении класса:

```kt
open class Transformer {...}

class Autobot(p: Int) : Transformer()
```

Если у класса есть основной конструктор, базовый класс может (и должен) быть проинициализирован там же, с использованием параметров основного конструктора.

Если у класса нет основного конструктора, тогда каждый последующий дополнительный конструктор должен включать в себя инициализацию базового класса с помощью ключевого слова **super** или давать отсылку на другой конструктор, который это делает. Примечательно, что любые дополнительные конструкторы могут ссылаться на разные конструкторы базового класса:

```kt
class MyView : View {
    constructor(ctx: Context) : super(ctx) {
    }

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) {
    }
}
```

Ключевое слово **open** является противоположностью слову **final** в Java: оно позволяет другим классам наследоваться от данного. По умолчанию, все классы в Kotlin имеют статус final.

### Абстрактные классы

Класс и некоторые его члены могут быть объявлены как *abstract*. Абстрактный метод не имеет реализации в своём классе. Обратите внимание, что нам не надо аннотировать абстрактный класс или функцию словом open - это подразумевается и так.

### Свойства и поля

#### Объявление свойств

Классы в Kotlin могут иметь свойства: изменяемые (mutable) и неизменяемые (read-only) — **var** и **val** соответственно (т.е. выглядят как обычные переменные).

```kt
public class Address 
{
    public var name: String = ...
    public var street: String = ...
    public var city: String = ...
    public var state: String? = ...
    public var zip: String = ...
}
```

Для того, чтобы воспользоваться свойством, мы просто обращаемся к его имени:

```kt
fun copyAddress(address: Address): Address {
    val result = Address() // нет никакого слова `new`
    result.name = address.name // получаем свойство класса
    result.street = address.street
    // ...
    return result
}
```

### Свойства с отложенной инициализацией

Обычно, свойства, объявленные non-null типом, должны быть проинициализированы в конструкторе. Однако, довольно часто это неосуществимо. К примеру, свойства могут быть инициализированы через внедрение зависимостей, в установочном методе (ориг.: "setup method") юнит-теста или в методе onCreate в Android. В таком случае вы не можете обеспечить non-null инициализацию в конструкторе, но всё равно хотите избежать проверок на null при обращении внутри тела класса к такому свойству.

Для того, чтобы справиться с такой задачей, вы можете пометить свойство модификатором **lateinit**:

```kt
public class MyTest {
    lateinit var subject: TestSubject

    @SetUp 
    fun setup() {
        subject = TestSubject()
    }

    @Test 
    fun test() {
        subject.method()  // объект инициализирован, проверять на null не нужно
    }
}
```

Такой модификатор может быть использован только с var свойствами, объявленными внутри тела класса (не в основном конструкторе, и только тогда, когда свойство не имеет пользовательских геттеров и сеттеров) и, начиная с Kotlin 1.2, со свойствами, расположенными на верхнем уровне, и локальными переменными. Тип такого свойства должен быть non-null и не должен быть примитивным.

Доступ к **lateinit** свойству до того, как оно проинициализировано, выбрасывает специальное исключение, которое чётко обозначает, что свойство не было определено.

### Проверка инициализации lateinit var (начиная с версии 1.2)

Чтобы проверить, было ли проинициализировано lateinit var свойство, используйте .isInitialized метод ссылки на это свойство:

```kt
if (foo::bar.isInitialized) {
    println(foo.bar)
}
```

### Реализация интерфейсов

Класс или объект могут реализовать любое количество интерфейсов:

```kt
class Child : MyInterface {
    override fun bar() {
        // тело
    }
}
```

### Модификаторы доступа

Классы, объекты, интерфейсы, конструкторы, функции, свойства и их сеттеры могут иметь модификаторы доступа (у геттеров всегда такая же видимость, как у свойств, к которым они относятся). В Kotlin предусмотрено четыре модификатора доступа: **private**, **protected**, **internal** и **public**. Если явно не используется никакого модификатора доступа, то по умолчанию применяется **public**.

### Пакеты

Функции, свойства, классы, объекты и интерфейсы могут быть объявлены на самом "высоком уровне" прямо внутри пакета:

```kt
// имя файла: example.kt
package foo

fun baz() {}
class Bar {}
```

* Если вы не укажете никакого модификатора доступа, будет использован **public**. Это значит, что весь код данного объявления будет виден в глобальной области видимости;
* Если вы пометите объявление словом **private**, оно будет видно только внутри файла, где было объявлено;
* Если вы используете **internal**, видимость будет распространяться на весь модуль;
* **protected** запрещено использовать в объявлениях "высокого уровня".

Примеры:

```kt
// имя файла: example.kt
package foo

private fun foo() {} // имеет видимость внутри example.kt

public var bar: Int = 5 // свойство видно со дна Марианской впадины
    private set         // сеттер видно только внутри example.kt
    
internal val baz = 6    // имеет видимость внутри модуля
```

#### Классы и интерфейсы

Для методов, объявленых в классе:

* **private** означает видимость только внутри этого класса;
* **protected** — то же самое, что и private + видимость в потомках;
* **internal** — любой клиент внутри модуля, который видит объявленный класс, видит и его internal члены;
* **public** — любой клиент, который видит объявленный класс, видит его public члены.

Примеры:

```kt
open class Outer {
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4  // public по умолчанию
    
    protected class Nested {
        public val e: Int = 5
    }
}

class Subclass : Outer() {
    // a не видно
    // b, c и d видно
    // класс Nested и его свойство e видно

    override val b = 5   // 'b' - protected
}

class Unrelated(o: Outer) {
    // o.a, o.b не видно
    // o.c и o.d видно (тот же модуль)
    // Outer.Nested не видно, и Nested::e также не видно
}
```

#### Область видимости конструктора

Для указания видимости основного конструктора класса используется следующий синтаксис:

```kt
class C private constructor(a: Int) { ... }
```

В этом примере конструктор является **private**. По умолчанию все конструкторы имеют модификатор доступа **public**, то есть видны везде, где виден сам класс (а вот конструктор internal класса видно только в том же модуле).

### Классы данных

Нередко мы создаём классы, единственным назначением которых является хранение данных. Функционал таких классов зависит от самих данных, которые в них хранятся. В Kotlin класс может быть отмечен словом data:

```kt
data class User(val name: String, val age: Int)
```

Такой класс называется классом данных. Компилятор автоматически формирует следующие члены данного класса из свойств, объявленных в основном конструкторе:

* пару функций equals()/hashCode(),
* функцию toString() в форме "User(name=John, age=42)",
* компонентные функции componentN(), которые соответствуют свойствам, в соответствии с порядком их объявления,
* функцию copy() (см. ниже)

Если какая-либо из этих функций явно определена в теле класса (или унаследована от родительского класса), то генерироваться она не будет.

Для обеспечения согласованности и осмысленного поведения сгенерированного кода классы данных должны удовлетворять следующим требованиям:

* Основной конструктор должен иметь как минимум один параметр;
* Все параметры основного конструктора должны быть отмечены, как val или var;
* Классы данных не могут быть абстрактными, open, sealed или inner;
* (до версии 1.1) Классы данных не могут наследоваться от других классов (но могут реализовывать интерфейсы).

Дополнительно, генерация членов классов данных при наследовании подчиняется следующим правилам:

* Если существуют явные реализации equals(), hashCode() или toString() в теле класса данных или конечные (final) реализации в суперклассе, то эти функции не генерируются, а используются существующие реализации;
* Если суперкласс включает функции componentN(), которые являются открытыми и возвращают совместимые типы, соответствующие компонентные функции создаются для класса данных и переопределяют функции суперкласса. Если функции суперкласса не могут быть переопределены из-за несовместимости сигнатур или являются конечными (final), выдаётся сообщение об ошибке;
* Наследование класса данных от типа, который уже имеет функцию copy(...) с совпадающей сигнатурой не рекомендуется в Kotlin 1.2 и запрещена в Kotlin 1.3;
* Предоставление явных реализаций для функций componentN() и copy() не допускается.

Для того, чтобы у сгенерированного в JVM класса был конструктор без параметров, значения всех свойств должны быть заданы по умолчанию

```kt
data class User(val name: String = "", val age: Int = 0)
```

#### Свойства, объявленные в теле класса

Обратите внимание, что компилятор использует только свойства, определенные в основном конструкторе для автоматически созданных функций. Чтобы исключить свойство из автоматически созданной реализации, объявите его в теле класса:

```kt
data class Person(val name: String) {
    var age: Int = 0
}
```

Только свойство *name* будет учитываться в реализациях функций toString(), equals(), hashCode() и copy(), и будет создана только одна компонентная функция component1(). Даже если два объекта класса Person будут иметь разные значения свойств age, они будут считаться равными.

```kt
val person1 = Person("John")
val person2 = Person("John")
person1.age = 10
person2.age = 20
println("${person1 == person2}") // выведет "true"
```
